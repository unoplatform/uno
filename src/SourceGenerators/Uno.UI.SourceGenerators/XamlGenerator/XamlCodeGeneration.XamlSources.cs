#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.Text;
using Uno.Extensions;
using Uno.UI.SourceGenerators.Helpers;
using Uno.UI.SourceGenerators.Utils;

namespace Uno.UI.SourceGenerators.XamlGenerator;

partial class XamlCodeGeneration
{
	private SourceText? GenerateEmbeddedXamlSources(XamlFileDefinition[] files)
	{
		var interestingFiles = new SortedSet<XamlFileDefinition>();

		foreach (var file in files)
		{
			if (file.Content.Length > 0)
			{
				interestingFiles.Add(file);
			}
		}

		if (interestingFiles.Count == 0)
		{
			return null;
		}

		const string embeddedXamlSourcesClassName = "EmbeddedXamlSourcesProvider";
		var writer = new IndentedStringBuilder();

		writer.AppendLineIndented("#nullable enable");
		writer.AppendLineIndented("// <autogenerated />");
		AnalyzerSuppressionsGenerator.Generate(writer, _analyzerSuppressions);

		writer.AppendLineIndented("#pragma warning disable // Disable all warnings for this generated file");
		writer.AppendLine();
		writer.AppendLineIndented("// Register an embedded sources provider for Hot Reload");
		writer.AppendLineInvariantIndented("[assembly: global::System.Reflection.AssemblyMetadata(\"Uno.HotDesign.HotReloadEmbeddedXamlSourceFilesProvider\", \"{0}.__Sources__.{1}\")]", _defaultNamespace, embeddedXamlSourcesClassName);
		writer.AppendLine();
		writer.AppendLineInvariantIndented("namespace {0}.__Sources__;", _defaultNamespace);
		writer.AppendLine();

		// Compute the checksum of all the files by hashing the content of the files, separated by a null character
		var filesListHash = HashBuilder.Build(string.Join("\0", interestingFiles.Select(f => f.FilePath)));

		writer.AppendLineIndented("/// <summary>");
		writer.AppendLineIndented("/// Provides access to the embedded XAML sources");
		writer.AppendLineIndented("/// </summary>");
		writer.AppendLineIndented("/// <remarks>");
		writer.AppendLineIndented("/// This class is used to provide the embedded XAML sources to the Hot Reload engine.");
		writer.AppendLineIndented("/// This is not intended to be used directly by application code.");
		writer.AppendLineIndented("/// WON'T BE GENERATED ON RELEASE BUILDS");
		writer.AppendLineIndented("/// </remarks>");
		using (writer.BlockInvariant("internal static class {0}", embeddedXamlSourcesClassName))
		{
			writer.AppendLineIndented("// key=absolute file path");
			writer.AppendLineIndented("private static global::System.Collections.Generic.IDictionary<string, (string ActualPath, global::System.Func<(string Hash, string Payload)> Getter)>? _XamlSources;");
			writer.AppendLine();
			writer.AppendLineIndented("// hash of all the paths");
			writer.AppendLineIndented("private static volatile string? _filesListHash;");
			writer.AppendLine();
			writer.AppendLineIndented("// get the current value of the update counter");
			writer.AppendLineIndented("private static volatile uint _updateCounter;");
			writer.AppendLine();
			writer.AppendLineIndented("private static readonly global::System.Text.Encoding _utf8 = global::System.Text.Encoding.UTF8;");
			writer.AppendLine();
			writer.AppendLineIndented("// The content of this method only changes when the file list changes");
			using (writer.BlockInvariant("private static global::System.Collections.Generic.IDictionary<string, (string ActualPath, global::System.Func<(string Hash, string Payload)> Getter)> EnsureInitialize()"))
			{
				writer.AppendLineInvariantIndented("const string currentListHash = \"{0}\"; // that's the hash of all the paths, used to detect changes in the file list following a HR operation", filesListHash);
				writer.AppendLine();
				writer.AppendLineIndented("// Determine if the sources have been updated or not initialized yet");
				writer.AppendLineIndented("var previousHashList = _XamlSources;");
				writer.AppendLineIndented("var needsUpdate = previousHashList is null || _filesListHash != currentListHash;");
				writer.AppendLine();
				using (writer.BlockInvariant("if (needsUpdate)"))
				{
					writer.AppendLineInvariantIndented("var xamlSources = new global::System.Collections.Generic.Dictionary<string, (string ActualPath, global::System.Func<(string Hash, string Payload)> Getter)>({0}, global::System.StringComparer.OrdinalIgnoreCase);", interestingFiles.Count);
					writer.AppendLine();
					writer.AppendLineIndented("// Use method groups to avoid closure allocation and ensure no lambda is created, to allow proper HR support");
					foreach (var f in interestingFiles)
					{
						writer.AppendLineInvariantIndented("xamlSources[NormalizePath(@\"{0}\")] = (NormalizePath(@\"{0}\"), GetSources_{1});", f.FilePath, f.UniqueID);
					}
					writer.AppendLine();
					using (writer.BlockInvariant("if (global::System.Threading.Interlocked.CompareExchange(ref _XamlSources, xamlSources, previousHashList) == previousHashList)"))
					{
						writer.AppendLineIndented("// The sources were updated successfully (no other thread modified them concurrently)");
						writer.AppendLineIndented("_filesListHash = currentListHash;");
						writer.AppendLineIndented("_updateCounter++;");
					}
				}
				writer.AppendLine();
				writer.AppendLineIndented("return _XamlSources;");
			}
			writer.AppendLine();
			writer.AppendLineIndented("/// <summary>");
			writer.AppendLineIndented("/// Gets the current update counter, used to detect changes in the sources.");
			writer.AppendLineIndented("/// </summary>");
			writer.AppendLineIndented("/// <remarks>");
			writer.AppendLineIndented("/// This counter is incremented each time a Hot Reload sources update is detected.");
			writer.AppendLineIndented("/// </remarks>");
			using (writer.BlockInvariant("public static uint UpdateCounter"))
			{
				using (writer.BlockInvariant("get"))
				{
					writer.AppendLineIndented("EnsureInitialize();");
					writer.AppendLineIndented("return _updateCounter;");
				}
			}
			writer.AppendLine();
			writer.AppendLineIndented("public static global::System.Collections.Generic.IReadOnlyList<string> GetXamlFilesList() => [.. EnsureInitialize().Keys];");

			writer.AppendLine();
			using (writer.BlockInvariant("public static string? GetNormalizedFileName(string path)"))
			{
				writer.AppendLineIndented("// Will return the normalized path if the file exists, or null if it doesn't.");
				writer.AppendLineIndented("// (the returned value will be constant for the file and can be used in a dictionary using an ordinal comparer)");
				writer.AppendLineIndented("var normalizedPath = NormalizePath(path);");
				writer.AppendLineIndented("return EnsureInitialize().TryGetValue(normalizedPath, out var entry) ? entry.ActualPath : null;");
			}

			writer.AppendLine();
			using (writer.BlockInvariant("public static (string ActualPath, string Hash, string Payload)? GetXamlFile(string path)"))
			{
				writer.AppendLineIndented("var normalizedPath = NormalizePath(path);");
				using (writer.BlockInvariant("if (EnsureInitialize().TryGetValue(normalizedPath, out var entry))"))
				{
					writer.AppendLineIndented("var sources = entry.Getter();");
					writer.AppendLineIndented("return (entry.ActualPath, sources.Hash, sources.Payload);");
				}
				writer.AppendLineIndented("return null;");
			}

			writer.AppendLine();
			writer.AppendLineIndented(@"private static string NormalizePath(string path) => path.Replace('\\', '/');");

			foreach (var f in interestingFiles)
			{
				writer.AppendLine();
				writer.AppendLineInvariantIndented("#region Sources for {0}", f.FilePath);

				var rawStringDelimiter = GetRawStringDelimiter(f.Content.AsSpan());

				using (writer.BlockInvariant("private static (string hash, string payload) GetSources_{0}()", f.UniqueID))
				{
					writer.AppendLineIndented("return (");
					using (writer.Indent())
					{
						writer.AppendLineInvariantIndented("\"{0}\", // hash", f.Checksum);
						writer.AppendLineInvariantIndented("_utf8.GetString({0}", rawStringDelimiter);
						writer.AppendMultiLineIndented(f.Content);
						writer.AppendLineInvariantIndented("{0}u8)); // Stored as UTF8 to minimize impact on assembly size / limitations", rawStringDelimiter);
					}
				}
				writer.AppendLineIndented("#endregion");
			}
		}

		return new StringBuilderBasedSourceText(writer.Builder);
	}

	private static string GetRawStringDelimiter(ReadOnlySpan<char> content)
	{
		var nbQuotes = 3; // Minimum triple quotes

		var i = 0;
		while (i < content.Length)
		{
			// Find the next occurrence of a quote
			var nextQuote = content.Slice(i).IndexOf('"');
			if (nextQuote == -1)
			{
				break; // No more quotes to process
			}

			i += nextQuote; // Move to the found quote

			var start = i;
			while (i + 1 < content.Length && content[i + 1] == '"')
			{
				i++;
			}

			var count = i - start + 1 + 1; // +1 for the zero-based index, +1 for the number of quotes required for escaping
			if (count > nbQuotes)
			{
				nbQuotes = count;
			}

			i++; // Move to the next character after the quote sequence
		}

		return nbQuotes == 3
			? "\"\"\"" // No need to escape, use triple quotes
			: new string('"', nbQuotes);
	}
}
