#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Uno.Extensions;
using Uno.Roslyn;
using Uno.UI.SourceGenerators.Helpers;
using Uno.UI.SourceGenerators.XamlGenerator;

namespace Uno.UI.SourceGenerators.DependencyObject
{
	[Generator]
	public partial class DependencyObjectGenerator : ISourceGenerator
	{
		public void Initialize(GeneratorInitializationContext context)
		{
			// Debugger.Launch();
			// No initialization required for this one
		}

		public void Execute(GeneratorExecutionContext context)
		{
			if (PlatformHelper.IsValidPlatform(context))
			{
				var visitor = new SerializationMethodsGenerator(context);
				visitor.Visit(context.Compilation.SourceModule);
			}
		}

		private class SerializationMethodsGenerator : SymbolVisitor
		{
			private static readonly char[] _commaArray = new[] { ',' };

			private readonly GeneratorExecutionContext _context;
			private readonly INamedTypeSymbol? _dependencyObjectSymbol;
			private readonly INamedTypeSymbol? _unoViewgroupSymbol;
			private readonly INamedTypeSymbol? _iosViewSymbol;
			private readonly INamedTypeSymbol? _macosViewSymbol;
			private readonly INamedTypeSymbol? _androidViewSymbol;
			private readonly INamedTypeSymbol? _javaObjectSymbol;
			private readonly INamedTypeSymbol? _androidActivitySymbol;
			private readonly INamedTypeSymbol? _androidFragmentSymbol;
			private readonly INamedTypeSymbol? _bindableAttributeSymbol;
			private readonly INamedTypeSymbol? _iFrameworkElementSymbol;
			private readonly INamedTypeSymbol? _frameworkElementSymbol;
			private readonly bool _isUnoSolution;
			private readonly string[] _analyzerSuppressions;

			public SerializationMethodsGenerator(GeneratorExecutionContext context)
			{
				_context = context;

				var comp = context.Compilation;

				_dependencyObjectSymbol = comp.GetTypeByMetadataName(XamlConstants.Types.DependencyObject);
				_unoViewgroupSymbol = comp.GetTypeByMetadataName("Uno.UI.UnoViewGroup");
				_iosViewSymbol = comp.GetTypeByMetadataName("UIKit.UIView");
				_macosViewSymbol = comp.GetTypeByMetadataName("AppKit.NSView");
				_androidViewSymbol = comp.GetTypeByMetadataName("Android.Views.View");
				_javaObjectSymbol = comp.GetTypeByMetadataName("Java.Lang.Object");
				_androidActivitySymbol = comp.GetTypeByMetadataName("Android.App.Activity");
				_androidFragmentSymbol = comp.GetTypeByMetadataName("AndroidX.Fragment.App.Fragment");
				_bindableAttributeSymbol = comp.GetTypeByMetadataName("Microsoft.UI.Xaml.Data.BindableAttribute");
				_iFrameworkElementSymbol = comp.GetTypeByMetadataName(XamlConstants.Types.IFrameworkElement);
				_frameworkElementSymbol = comp.GetTypeByMetadataName("Microsoft.UI.Xaml.FrameworkElement");
				_isUnoSolution = _context.GetMSBuildPropertyValue("_IsUnoUISolution") == "true";
				_analyzerSuppressions = context.GetMSBuildPropertyValue("XamlGeneratorAnalyzerSuppressionsProperty").Split(_commaArray, StringSplitOptions.RemoveEmptyEntries);
			}

			public override void VisitNamedType(INamedTypeSymbol type)
			{
				_context.CancellationToken.ThrowIfCancellationRequested();

				foreach (var t in type.GetTypeMembers())
				{
					VisitNamedType(t);
				}

				ProcessType(type);
			}

			public override void VisitModule(IModuleSymbol symbol)
			{
				_context.CancellationToken.ThrowIfCancellationRequested();

				VisitNamespace(symbol.GlobalNamespace);
			}

			public override void VisitNamespace(INamespaceSymbol symbol)
			{
				_context.CancellationToken.ThrowIfCancellationRequested();

				foreach (var n in symbol.GetNamespaceMembers())
				{
					VisitNamespace(n);
				}

				foreach (var t in symbol.GetTypeMembers())
				{
					VisitNamedType(t);
				}
			}

			private void ProcessType(INamedTypeSymbol typeSymbol)
			{
				_context.CancellationToken.ThrowIfCancellationRequested();

				if (typeSymbol.TypeKind != TypeKind.Class)
				{
					return;
				}

				var isDependencyObject = typeSymbol.Interfaces.Any(t => SymbolEqualityComparer.Default.Equals(t, _dependencyObjectSymbol))
					&& (typeSymbol.BaseType?.AllInterfaces.None(t => SymbolEqualityComparer.Default.Equals(t, _dependencyObjectSymbol)) ?? true);

				if (isDependencyObject)
				{
					if (!_isUnoSolution)
					{
						if (typeSymbol.Is(_iosViewSymbol))
						{
							ReportDiagnostic(_context, Diagnostic.Create(_descriptor, typeSymbol.Locations[0], "UIKit.UIView"));
							return;
						}
						else if (typeSymbol.Is(_androidViewSymbol))
						{
							ReportDiagnostic(_context, Diagnostic.Create(_descriptor, typeSymbol.Locations[0], "Android.Views.View"));
							return;
						}
						else if (typeSymbol.Is(_macosViewSymbol))
						{
							ReportDiagnostic(_context, Diagnostic.Create(_descriptor, typeSymbol.Locations[0], "AppKit.NSView"));
							return;
						}
					}

					var builder = new IndentedStringBuilder();
					builder.Append(@"// <auto-generated>
// ******************************************************************
// This file has been generated by Uno.UI (DependencyObjectGenerator)
// ******************************************************************
// </auto-generated>

#pragma warning disable 1591 // Ignore missing XML comment warnings
");

					AnalyzerSuppressionsGenerator.Generate(builder, _analyzerSuppressions);

					builder.Append(@"
using System;
using System.Linq;
using System.Collections.Generic;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using Uno.Disposables;
using System.Runtime.CompilerServices;
using Uno.UI;
using Uno.UI.Controls;
using Uno.UI.DataBinding;
using Microsoft.UI.Xaml;
using Microsoft.UI.Xaml.Data;
using Uno.Diagnostics.Eventing;
");
					Action<IIndentedStringBuilder> beforeClassHeaderAction = builder =>
					{
						if (_bindableAttributeSymbol != null && typeSymbol.FindAttribute(_bindableAttributeSymbol) == null)
						{
							builder.AppendLineIndented(@"[global::Microsoft.UI.Xaml.Data.Bindable]");
						}
					};

					var implementations = new string?[]
					{
						"IDependencyObjectStoreProvider",
						_isUnoSolution && !typeSymbol.IsSealed ? "IDependencyObjectInternal" : null,
						"IWeakReferenceProvider",
					}.Where(x => x is not null);
					using (typeSymbol.AddToIndentedStringBuilder(builder, beforeClassHeaderAction, afterClassHeader: " : " + string.Join(", ", implementations)))
					{
						GenerateDependencyObjectImplementation(typeSymbol, builder, hasDispatcherQueue: _dependencyObjectSymbol!.GetMembers("DispatcherQueue").Any());
						GenerateIBinderImplementation(typeSymbol, builder);
					}

					_context.AddSource(typeSymbol.GetFullMetadataNameForFileName(), builder.ToString());
				}
			}

			private void GenerateIBinderImplementation(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				WriteInitializer(typeSymbol, builder);

				WriteToStringOverride(typeSymbol, builder);

				WriteAndroidEqualityOverride(typeSymbol, builder);

				WriteAndroidBinderDetails(typeSymbol, builder);

				WriteAndroidAttachedToWindow(typeSymbol, builder);

				WriteAttachToWindow(typeSymbol, builder);
				WriteViewDidMoveToWindow(typeSymbol, builder);

				WriteiOSMoveToSuperView(typeSymbol, builder);
				WriteMacOSViewWillMoveToSuperview(typeSymbol, builder);

				WriteDispose(typeSymbol, builder);
				WriteBinderImplementation(typeSymbol, builder);
			}

			private void WriteToStringOverride(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var hasNoToString = typeSymbol
					.GetMethodsWithName("ToString")
					.None(m => IsNotDependencyObjectGeneratorSourceFile(m));

				if (hasNoToString)
				{
					builder.AppendIndented(@"public override string ToString() => GetType().FullName;");
				}
			}

			private void WriteiOSMoveToSuperView(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var isiosView = typeSymbol.Is(_iosViewSymbol);
				var hasNoWillMoveToSuperviewMethod = typeSymbol
					.GetMethodsWithName("WillMoveToSuperview")
					.None(m => IsNotDependencyObjectGeneratorSourceFile(m));

				var overridesWillMoveToSuperview = isiosView && hasNoWillMoveToSuperviewMethod;

				if (overridesWillMoveToSuperview)
				{
					builder.AppendMultiLineIndented(@"
public override void WillMoveToSuperview(UIKit.UIView newsuper)
{
	base.WillMoveToSuperview(newsuper);

	WillMoveToSuperviewPartial(newsuper);
}

partial void WillMoveToSuperviewPartial(UIKit.UIView newsuper);
					");
				}
				else
				{
					builder.AppendIndented($"// Skipped _iosViewSymbol: {typeSymbol.Is(_iosViewSymbol)}, hasNoWillMoveToSuperviewMethod: {hasNoWillMoveToSuperviewMethod}");
				}
			}

			private void WriteMacOSViewWillMoveToSuperview(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var isiosView = typeSymbol.Is(_macosViewSymbol);
				var hasNoWillMoveToSuperviewMethod = typeSymbol
					.GetMethodsWithName("ViewWillMoveToSuperview")
					.None(m => IsNotDependencyObjectGeneratorSourceFile(m));

				var overridesWillMoveToSuperview = isiosView && hasNoWillMoveToSuperviewMethod;

				if (overridesWillMoveToSuperview)
				{
					builder.AppendMultiLineIndented(@"
public override void ViewWillMoveToSuperview(AppKit.NSView newsuper)
{
	base.ViewWillMoveToSuperview(newsuper);

	WillMoveToSuperviewPartial(newsuper);
}

partial void WillMoveToSuperviewPartial(AppKit.NSView newsuper);
					");
				}
				else
				{
					builder.AppendIndented($"// Skipped _macosViewSymbol: {typeSymbol.Is(_macosViewSymbol)}, hasNoViewWillMoveToSuperviewMethod: {hasNoWillMoveToSuperviewMethod}");
					builder.AppendLine();
				}
			}

			private void WriteAndroidAttachedToWindow(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var isAndroidView = typeSymbol.Is(_androidViewSymbol);
				var isAndroidActivity = typeSymbol.Is(_androidActivitySymbol);
				var isAndroidFragment = typeSymbol.Is(_androidFragmentSymbol);
				var isUnoViewGroup = typeSymbol.Is(_unoViewgroupSymbol);
				var implementsIFrameworkElement = typeSymbol.Interfaces.Any(t => SymbolEqualityComparer.Default.Equals(t, _iFrameworkElementSymbol));
				var hasOverridesAttachedToWindowAndroid = isAndroidView &&
					typeSymbol
					.GetMethodsWithName("OnAttachedToWindow")
					.None(m => IsNotDependencyObjectGeneratorSourceFile(m));

				if (isAndroidView || isAndroidActivity || isAndroidFragment)
				{
					builder.AppendMultiLineIndented($@"
#if {hasOverridesAttachedToWindowAndroid} //Is Android view (that doesn't already override OnAttachedToWindow)

#if {isUnoViewGroup} //Is UnoViewGroup
					// Both methods below are implementation of abstract methods
					// which are called from onAttachedToWindow in Java.

					protected override void OnNativeLoaded()
					{{
						BinderAttachedToWindow();
					}}

					protected override void OnNativeUnloaded()
					{{
						BinderDetachedFromWindow();
					}}
#else //Not UnoViewGroup
					protected override void OnAttachedToWindow()
					{{
						base.OnAttachedToWindow();
						__Store.Parent = base.Parent;
#if {implementsIFrameworkElement} //Is IFrameworkElement
						OnLoading();
						OnLoaded();
#endif
						BinderAttachedToWindow();
					}}


					protected override void OnDetachedFromWindow()
					{{
						base.OnDetachedFromWindow();
#if {implementsIFrameworkElement} //Is IFrameworkElement
						OnUnloaded();
#endif
					if(base.Parent == null)
					{{
						__Store.Parent = null;
					}}

						BinderDetachedFromWindow();
					}}
#endif // IsUnoViewGroup
#endif // OverridesAttachedToWindow

					private void BinderAttachedToWindow()
					{{
						OnAttachedToWindowPartial();
					}}


					private void BinderDetachedFromWindow()
					{{
						OnDetachedFromWindowPartial();
					}}

					/// <summary>
					/// A method called when the control is attached to the Window (equivalent of Loaded)
					/// </summary>
					partial void OnAttachedToWindowPartial();

					/// <summary>
					/// A method called when the control is attached to the Window (equivalent of Unloaded)
					/// </summary>
					partial void OnDetachedFromWindowPartial();
				");
				}
			}

			private void WriteAttachToWindow(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var hasOverridesAttachedToWindowiOS = typeSymbol.Is(_iosViewSymbol) &&
									typeSymbol
									.GetMethodsWithName("MovedToWindow")
									.None(m => IsNotDependencyObjectGeneratorSourceFile(m));

				if (hasOverridesAttachedToWindowiOS)
				{
					builder.AppendMultiLineIndented($@"
public override void MovedToWindow()
{{
	base.MovedToWindow();

	if(Window != null)
	{{
		OnAttachedToWindowPartial();
	}}
	else
	{{
		OnDetachedFromWindowPartial();
	}}
}}

/// <summary>
/// A method called when the control is attached to the Window (equivalent of Loaded)
/// </summary>
partial void OnAttachedToWindowPartial();

/// <summary>
/// A method called when the control is attached to the Window (equivalent of Unloaded)
/// </summary>
partial void OnDetachedFromWindowPartial();
					");
				}
				else
				{
					builder.AppendIndented($@"// hasOverridesAttachedToWindowiOS=false");
				}
			}

			private void WriteViewDidMoveToWindow(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var hasOverridesAttachedToWindowiOS = typeSymbol.Is(_macosViewSymbol) &&
									typeSymbol
									.GetMethodsWithName("ViewDidMoveToWindow")
									.Where(m => IsNotDependencyObjectGeneratorSourceFile(m))
									.None();

				if (hasOverridesAttachedToWindowiOS)
				{
					builder.AppendMultiLineIndented($@"
public override void ViewDidMoveToWindow()
{{
	base.ViewDidMoveToWindow();

	if(Window != null)
	{{
		OnAttachedToWindowPartial();
	}}
	else
	{{
		OnDetachedFromWindowPartial();
	}}
}}

/// <summary>
/// A method called when the control is attached to the Window (equivalent of Loaded)
/// </summary>
partial void OnAttachedToWindowPartial();

/// <summary>
/// A method called when the control is attached to the Window (equivalent of Unloaded)
/// </summary>
partial void OnDetachedFromWindowPartial();
					");
				}
				else
				{
					builder.AppendIndented($@"// hasOverridesAttachedToWindowiOS=false");
				}
			}

			private static bool IsNotDependencyObjectGeneratorSourceFile(IMethodSymbol m)
			{
				return !m.Locations.FirstOrDefault()?.SourceTree?.FilePath.Contains(nameof(DependencyObjectGenerator)) ?? true;
			}

			private void WriteAndroidBinderDetails(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var hasBinderDetails = typeSymbol.Is(_androidViewSymbol);

				if (hasBinderDetails)
				{
					builder.AppendMultiLineIndented($@"
public BinderDetails GetBinderDetail()
{{
	return null;
}}
					");
				}
			}

			private static void WriteInitializer(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var content = $@"
private readonly static IEventProvider _binderTrace = Tracing.Get(DependencyObjectStore.TraceProvider.Id);
private BinderReferenceHolder _refHolder;

public event global::Windows.Foundation.TypedEventHandler<FrameworkElement, DataContextChangedEventArgs> DataContextChanged;

partial void InitializeBinder();

private void __InitializeBinder()
{{
	if(BinderReferenceHolder.IsEnabled)
	{{
		_refHolder = new BinderReferenceHolder(this.GetType(), this);
	}}
}}

private global::Uno.UI.DataBinding.ManagedWeakReference _selfWeakReference;
global::Uno.UI.DataBinding.ManagedWeakReference IWeakReferenceProvider.WeakReference
{{
	get
	{{
		if(_selfWeakReference == null)
		{{
			_selfWeakReference = global::Uno.UI.DataBinding.WeakReferencePool.RentSelfWeakReference(this);
		}}

		return _selfWeakReference;
	}}
}}
				";

				builder.AppendMultiLineIndented(content);
			}

			private void WriteDispose(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var hasDispose = typeSymbol.Is(_iosViewSymbol) || typeSymbol.Is(_macosViewSymbol);

				if (hasDispose)
				{
					builder.AppendMultiLineIndented($@"
#if __APPLE_UIKIT__ || __IOS__ || __TVOS__
					private bool _isDisposed;

					[SuppressMessage(
						""Microsoft.Usage"",
						""CA2215:DisposeMethodsShouldCallBaseClassDispose"",
						Justification = ""The dispose is re-scheduled in order to properly remove children from their parent"")]
					protected sealed override void Dispose(bool disposing)
					{{
						// This method is present in order to ensure for faster collection of a disposed visual tree
						// as well as ensure that instances can be properly returned to the FrameworkTemplatePool.
						//
						// This method can be called by the finalizer, in which case the object is re-registered 
						// for finalization, and the Dispose method is invoked explicitly during a idle dispatch.
						// 
						// This operation can fail if Dispose() is called by user code on UIView instances.
						// The Roslyn analyzer UnoDoNotDisposeNativeViews will warn the developer if this is the case.
						// 
						// For native exceptions that may be raised if Disposed is called incorrectly, see 
						// https://github.com/xamarin/xamarin-macios/issues/19493.

						if(_isDisposed)
						{{
							base.Dispose(disposing);
							return;
						}}

						if (disposing)
						{{
							// __Store may be null if the control has been recreated from
							// a native representation via the IntPtr ctor, particularly on iOS.
							__Store?.Dispose();

#if __APPLE_UIKIT__ || __IOS__ || __TVOS__
							var subviews = Subviews;

							if (subviews.Length > 0)
							{{
								BinderCollector.RequestCollect();
								foreach (var v in subviews)
								{{
									v.RemoveFromSuperview();
								}}
							}}
#endif

							base.Dispose(disposing);

							_isDisposed = true;
						}}
						else
						{{
							GC.ReRegisterForFinalize(this);

							_ = Dispatcher.RunIdleAsync(_ => Dispose());
						}}
					}}
#endif
				");
				}
			}

			private void WriteBinderImplementation(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var virtualModifier = typeSymbol.IsSealed ? "" : "virtual";
				var protectedModifier = typeSymbol.IsSealed ? "private" : "internal protected";
				var legacyNonBrowsable = "[EditorBrowsable(EditorBrowsableState.Never)]";

				string dataContextChangedInvokeArgument;
				if (typeSymbol.Is(_frameworkElementSymbol))
				{
					// We can pass 'this' safely to a parameter of type FrameworkElement.
					dataContextChangedInvokeArgument = "this";
				}
				else if (_frameworkElementSymbol.Is(typeSymbol))
				{
					// Example: Border -> FrameworkElement -> BindableView
					// If we have a BindableView, it may or may not be FrameworkElement.
					dataContextChangedInvokeArgument = "this as FrameworkElement";
				}
				else
				{
					// This can't be a FrameworkElement. Just pass null.
					// Passing `this as FrameworkElement` will produce a compile-time error.
					// error CS0039: Cannot convert type '{0}' to '{1}' via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion
					dataContextChangedInvokeArgument = "null";
				}

				builder.AppendMultiLineIndented($@"

#region DataContext DependencyProperty

public object DataContext
{{
	get => GetValue(DataContextProperty);
	set => SetValue(DataContextProperty, value);
}}

// Using a DependencyProperty as the backing store for DataContext.  This enables animation, styling, binding, etc...
public static DependencyProperty DataContextProperty {{ get ; }} =
	DependencyProperty.Register(
		name: nameof(DataContext),
		propertyType: typeof(object),
		ownerType: typeof({typeSymbol.Name}),
		typeMetadata: new FrameworkPropertyMetadata(
			defaultValue: null,
			options: FrameworkPropertyMetadataOptions.Inherits,
			propertyChangedCallback: (s, e) => (({typeSymbol.Name})s).OnDataContextChanged(e)
		)
);

{protectedModifier} {virtualModifier} void OnDataContextChanged(DependencyPropertyChangedEventArgs e)
{{
	OnDataContextChangedPartial(e);
	DataContextChanged?.Invoke({dataContextChangedInvokeArgument}, new DataContextChangedEventArgs(DataContext));
}}

#endregion

#region TemplatedParent DependencyProperty // legacy api, should no longer to be used.

{legacyNonBrowsable}public DependencyObject TemplatedParent
{{
	get => (DependencyObject)GetValue(TemplatedParentProperty);
	set => SetValue(TemplatedParentProperty, value);
}}

// Using a DependencyProperty as the backing store for TemplatedParent.  This enables animation, styling, binding, etc...
{legacyNonBrowsable}
public static DependencyProperty TemplatedParentProperty {{ get ; }} =
	DependencyProperty.Register(
		name: nameof(TemplatedParent),
		propertyType: typeof(DependencyObject),
		ownerType: typeof({typeSymbol.Name}),
		typeMetadata: new FrameworkPropertyMetadata(
			defaultValue: null,
			options: /*FrameworkPropertyMetadataOptions.Inherits | */FrameworkPropertyMetadataOptions.ValueDoesNotInheritDataContext | FrameworkPropertyMetadataOptions.WeakStorage,
			propertyChangedCallback: (s, e) => (({typeSymbol.Name})s).OnTemplatedParentChanged(e)
		)
	);


{legacyNonBrowsable}
{protectedModifier} {virtualModifier} void OnTemplatedParentChanged(DependencyPropertyChangedEventArgs e)
{{
	OnTemplatedParentChangedPartial(e);
}}

#endregion

public void SetBinding(object target, string dependencyProperty, global::Microsoft.UI.Xaml.Data.BindingBase binding)
{{
	__Store.SetBinding(target, dependencyProperty, binding);
}}

public void SetBinding(string dependencyProperty, global::Microsoft.UI.Xaml.Data.BindingBase binding)
{{
	__Store.SetBinding(dependencyProperty, binding);
}}

public void SetBinding(DependencyProperty dependencyProperty, global::Microsoft.UI.Xaml.Data.BindingBase binding)
{{
	__Store.SetBinding(dependencyProperty, binding);
}}

public void SetBindingValue(object value, [CallerMemberName] string propertyName = null)
{{
	__Store.SetBindingValue(value, propertyName);
}}

[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
internal bool IsAutoPropertyInheritanceEnabled {{ get => __Store.IsAutoPropertyInheritanceEnabled; set => __Store.IsAutoPropertyInheritanceEnabled = value; }}

partial void OnDataContextChangedPartial(DependencyPropertyChangedEventArgs e);

{legacyNonBrowsable}
partial void OnTemplatedParentChangedPartial(DependencyPropertyChangedEventArgs e);

public global::Microsoft.UI.Xaml.Data.BindingExpression GetBindingExpression(DependencyProperty dependencyProperty)
	=>  __Store.GetBindingExpression(dependencyProperty);

public void ResumeBindings()
	=>__Store.ResumeBindings();

public void SuspendBindings() =>
	__Store.SuspendBindings();
				");
			}

			private void WriteAndroidEqualityOverride(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder)
			{
				var hasEqualityOverride = typeSymbol
					.GetMethodsWithName("Equals")
					.None(m => IsNotDependencyObjectGeneratorSourceFile(m))
					&& (typeSymbol.BaseType?.GetMethodsWithName("Equals").None(m => m.IsSealed) ?? true);

				if (hasEqualityOverride && typeSymbol.Is(_androidViewSymbol))
				{
					builder.AppendMultiLineIndented($@"
public override int GetHashCode()
{{
	// For the the current kind of type, we do not need to call back
	// to android for the GetHashCode implementation. The .NET proxy hash is
	// enough. This way, we do not get to pay the price of the interop to get
	// this value.
	return RuntimeHelpers.GetHashCode(this);
}}

public override bool Equals(object other)
{{
	// For the the current kind of type, we do not need to call back
	// to android for the Equals implementation. We assume that proxies are
	// one-to-one mapping with native instances, making the reference comparison
	// of proxies enough to do the job.
	return RuntimeHelpers.ReferenceEquals(this, other);
}}
					");
				}
			}

			private void GenerateDependencyObjectImplementation(INamedTypeSymbol typeSymbol, IndentedStringBuilder builder, bool hasDispatcherQueue)
			{
				builder.AppendLineIndented(@"private DependencyObjectStore __storeBackingField;");
				builder.AppendLineIndented(@"public global::Windows.UI.Core.CoreDispatcher Dispatcher => global::Windows.ApplicationModel.Core.CoreApplication.MainView.Dispatcher;");

				if (hasDispatcherQueue)
				{
					builder.AppendLineIndented(@"public global::Microsoft.UI.Dispatching.DispatcherQueue DispatcherQueue { get; } = global::Microsoft.UI.Dispatching.DispatcherQueue.GetForCurrentThread();");
				}

				using (builder.BlockInvariant($"private DependencyObjectStore __Store"))
				{
					using (builder.BlockInvariant($"get"))
					{
						using (builder.BlockInvariant($"if(__storeBackingField == null)"))
						{
							builder.AppendLineIndented("__storeBackingField = new DependencyObjectStore(this, DataContextProperty);");
							builder.AppendLineIndented("__InitializeBinder();");
						}

						builder.AppendLineIndented("return __storeBackingField;");
					}
				}
				builder.AppendLineIndented(@"public bool IsStoreInitialized => __storeBackingField != null;");

				builder.AppendLineIndented(@"DependencyObjectStore IDependencyObjectStoreProvider.Store => __Store;");

				builder.AppendLineIndented("public object GetValue(DependencyProperty dp) => __Store.GetValue(dp);");

				builder.AppendLineIndented("public void SetValue(DependencyProperty dp, object value) => __Store.SetValue(dp, value);");

				builder.AppendLineIndented("public void ClearValue(DependencyProperty dp) => __Store.ClearValue(dp);");

				builder.AppendLineIndented("public object ReadLocalValue(DependencyProperty dp) => __Store.ReadLocalValue(dp);");

				builder.AppendLineIndented("public object GetAnimationBaseValue(DependencyProperty dp) => __Store.GetAnimationBaseValue(dp);");

				builder.AppendLineIndented("public long RegisterPropertyChangedCallback(DependencyProperty dp, DependencyPropertyChangedCallback callback) => __Store.RegisterPropertyChangedCallback(dp, callback);");

				builder.AppendLineIndented("public void UnregisterPropertyChangedCallback(DependencyProperty dp, long token) => __Store.UnregisterPropertyChangedCallback(dp, token);");

				if (_isUnoSolution && !typeSymbol.IsSealed)
				{
					builder.AppendLineIndented("void IDependencyObjectInternal.OnPropertyChanged2(global::Microsoft.UI.Xaml.DependencyPropertyChangedEventArgs args) => OnPropertyChanged2(args);");

					if (typeSymbol.GetMethodsWithName("OnPropertyChanged2").None(m => m.Parameters.Length == 1))
					{
						builder.AppendLineIndented("internal virtual void OnPropertyChanged2(global::Microsoft.UI.Xaml.DependencyPropertyChangedEventArgs args) { }");
					}
				}
			}
		}
	}
}
