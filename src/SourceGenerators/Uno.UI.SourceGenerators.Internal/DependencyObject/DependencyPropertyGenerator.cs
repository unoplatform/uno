#nullable enable

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Uno.Extensions;
using Uno.UI.SourceGenerators.Helpers;
using Uno.UI.SourceGenerators.Internal.Extensions;
using Uno.UI.SourceGenerators.XamlGenerator;

namespace Uno.UI.SourceGenerators.DependencyObject
{
	// TODO: We are not respecting IsValidPlatform now.
	[Generator]
	public class DependencyPropertyGenerator : IIncrementalGenerator
	{
		private readonly struct FieldOrPropertyData
		{
			public ISymbol FieldOrPropertySymbol { get; }
			public AttributeData Attribute { get; }

			public FieldOrPropertyData(ISymbol fieldOrPropertySymbol, AttributeData attribute)
			{
				FieldOrPropertySymbol = fieldOrPropertySymbol;
				Attribute = attribute;
			}
		}

		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			var dependencyObjectProvider = context.CompilationProvider.Select((c, _) => c.GetTypeByMetadataName(XamlConstants.Types.DependencyObject));

			var attributedSymbolsProvider = context.SyntaxProvider.ForAttributeWithMetadataName(
				"Uno.UI.Xaml.GeneratedDependencyPropertyAttribute",
				static (node, _) => node.IsKind(SyntaxKind.FieldDeclaration) || node.IsKind(SyntaxKind.PropertyDeclaration),
				static (context, token) =>
				{
					var attribute = context.Attributes[0];
					return new FieldOrPropertyData(context.TargetSymbol, attribute);
				});

			var filteredAttributedSymbolsProvider = attributedSymbolsProvider.Combine(dependencyObjectProvider).Where(combined =>
			{
				var fieldOrPropertyData = combined.Left;
				var dependencyObjectSymbol = combined.Right;
				var containingType = fieldOrPropertyData.FieldOrPropertySymbol.ContainingType;
				return containingType.TypeKind == TypeKind.Class &&
					(containingType.IsStatic || containingType.GetAllInterfaces().Any(t => SymbolEqualityComparer.Default.Equals(t, dependencyObjectSymbol)));
			});

			var groupedByContainingProvider = filteredAttributedSymbolsProvider.Select((x, _) => x.Left).GroupBy(data => data.FieldOrPropertySymbol.ContainingType, SymbolEqualityComparer.Default);
			var finalProvider = groupedByContainingProvider.Combine(context.CompilationProvider.Select((c, _) => c.GetTypeByMetadataName("Windows.UI.Xaml.DependencyPropertyChangedEventArgs")));
			context.RegisterSourceOutput(finalProvider, static (context, item) =>
			{
				var fieldsAndProperties = item.Left;
				var dependencyPropertyChangedEventArgsSymbol = item.Right;
				if (dependencyPropertyChangedEventArgsSymbol is null)
				{
					// Consider reporting a diagnostic?
					return;
				}

				if (fieldsAndProperties.Length == 0)
				{
					return;
				}

				var typeSymbol = fieldsAndProperties[0].FieldOrPropertySymbol.ContainingType;

				var builder = new IndentedStringBuilder();
				builder.AppendLineIndented("// <auto-generated>");
				builder.AppendLineIndented("// ******************************************************************");
				builder.AppendLineIndented("// This file has been generated by Uno.UI (DependencyPropertyGenerator)");
				builder.AppendLineIndented("// ******************************************************************");
				builder.AppendLineIndented("// </auto-generated>");
				builder.AppendLine();
				builder.AppendLineIndented("#pragma warning disable 1591 // Ignore missing XML comment warnings");
				builder.AppendLineIndented($"using System;");
				builder.AppendLineIndented($"using System.Linq;");
				builder.AppendLineIndented($"using System.Collections.Generic;");
				builder.AppendLineIndented($"using System.Collections;");
				builder.AppendLineIndented($"using System.Diagnostics.CodeAnalysis;");
				builder.AppendLineIndented($"using Uno.Disposables;");
				builder.AppendLineIndented($"using System.Runtime.CompilerServices;");
				builder.AppendLineIndented($"using Uno.UI;");
				builder.AppendLineIndented($"using Uno.UI.DataBinding;");
				builder.AppendLineIndented($"using Windows.UI.Xaml;");
				builder.AppendLineIndented($"using Windows.UI.Xaml.Controls;");
				builder.AppendLineIndented($"using Windows.UI.Xaml.Data;");
				builder.AppendLineIndented($"using Uno.Diagnostics.Eventing;");

				var attachedPropertiesBackingFieldStatements = new Dictionary<INamedTypeSymbol, List<string>>(SymbolEqualityComparer.Default);

				using (builder.BlockInvariant($"namespace {typeSymbol.ContainingNamespace}"))
				{
					using (GenerateNestingContainers(builder, typeSymbol))
					{
						using (builder.BlockInvariant($"partial class {typeSymbol.Name}"))
						{
							foreach (var fieldOrPropertyData in fieldsAndProperties)
							{
								var memberSymbol = fieldOrPropertyData.FieldOrPropertySymbol;
								var attribute = fieldOrPropertyData.Attribute;
								var isAttached = GetBooleanAttributeValue(attribute, "Attached", false);

								if (isAttached)
								{
									GenerateAttachedProperty(builder, typeSymbol, memberSymbol, attribute, attachedPropertiesBackingFieldStatements, dependencyPropertyChangedEventArgsSymbol);
								}
								else
								{
									GenerateProperty(builder, typeSymbol, memberSymbol, attribute, dependencyPropertyChangedEventArgsSymbol);
								}
							}
						}
					}
				}

				foreach (var backingFieldType in attachedPropertiesBackingFieldStatements)
				{
					using (builder.BlockInvariant($"namespace {backingFieldType.Key.ContainingNamespace}"))
					{
						using (GenerateNestingContainers(builder, backingFieldType.Key))
						{
							using (builder.BlockInvariant($"partial class {backingFieldType.Key.Name}"))
							{
								foreach (var statement in backingFieldType.Value)
								{
									builder.AppendLineIndented(statement);
								}
							}
						}
					}
				}

				context.AddSource(HashBuilder.BuildIDFromSymbol(typeSymbol), builder.ToString());
			});
		}


		private static void GenerateAttachedProperty(IndentedStringBuilder builder, INamedTypeSymbol ownerType, ISymbol memberSymbol, AttributeData attribute, Dictionary<INamedTypeSymbol, List<string>> backingFieldStatements, INamedTypeSymbol dependencyPropertyChangedEventArgsSymbol)
		{
			var propertyName = memberSymbol.Name.TrimEnd("Property", StringComparison.Ordinal);

			var getMethodSymbol = ownerType.GetFirstMethodWithName("Get" + propertyName);
			var setMethodSymbol = ownerType.GetFirstMethodWithName("Set" + propertyName);

			if (getMethodSymbol == null)
			{
				builder.AppendLineIndented($"#error unable to find getter method for {propertyName} on {ownerType}");
				return;
			}

			if (setMethodSymbol == null)
			{
				builder.AppendLineIndented($"#error unable to find setter method for {propertyName} on {ownerType}");
				return;
			}

			var attachedBackingFieldOwner = GetAttributeValue(attribute, "AttachedBackingFieldOwner");
			var metadataOptions = GetAttributeValue(attribute, "Options")?.Value.Value?.ToString() ?? "0";
			var coerceCallback = GetBooleanAttributeValue(attribute, "CoerceCallback", false);
			var changedCallback = GetBooleanAttributeValue(attribute, "ChangedCallback", false);
			var localCache = GetBooleanAttributeValue(attribute, "LocalCache", true);
			var defaultValue = GetAttributeValue(attribute, "DefaultValue");
			var changedCallbackName = GetAttributeValue(attribute, "ChangedCallbackName")?.Value.Value?.ToString();

			var propertyTypeSymbol = getMethodSymbol.ReturnType;
			var propertyTargetSymbol = getMethodSymbol.Parameters.First().Type;
			var propertyOwnerType = getMethodSymbol.ContainingType;
			var propertyTypeName = propertyTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var propertyOwnerTypeName = propertyOwnerType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var propertyTargetName = propertyTargetSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

			var attachedBackingFieldOwnerSymbol = attachedBackingFieldOwner?.Value.Value as INamedTypeSymbol;
			var backingFieldOwnerTypeName = attachedBackingFieldOwnerSymbol != null
				? attachedBackingFieldOwnerSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
				: "";
			var backingFieldName = $"__{propertyOwnerType.Name}_{propertyName}PropertyBackingField";

			ValidateInvocation(builder, memberSymbol, $"Create{propertyName}Property");
			ValidateInvocation(builder, getMethodSymbol, $"Get{propertyName}Value");
			ValidateInvocation(builder, setMethodSymbol, $"Set{propertyName}Value");

			builder.AppendLineIndented($"");
			builder.AppendLineIndented($"");
			builder.AppendLineIndented($"#region {propertyName} Dependency Property");

			using (builder.BlockInvariant($"private static {propertyTypeName} Get{propertyName}Value({propertyTargetName} instance)"))
			{
				if (localCache)
				{
					if (!attachedBackingFieldOwner.HasValue)
					{
						builder.AppendLineIndented($"#error local cache methods must have AttachedBackingFieldOwner set");
						return;
					}

					if (attachedBackingFieldOwnerSymbol != null)
					{
						if (!backingFieldStatements.TryGetValue(attachedBackingFieldOwnerSymbol, out var statementList))
						{
							statementList = backingFieldStatements[attachedBackingFieldOwnerSymbol] = new List<string>();
						}

						statementList.Add($"internal bool {backingFieldName}Set;");
						statementList.Add($"internal {propertyTypeName} {backingFieldName};");
					}

					using (builder.BlockInvariant($"if(instance is {backingFieldOwnerTypeName} backingFieldOwnerInstance)"))
					{
						using (builder.BlockInvariant($"if (!backingFieldOwnerInstance.{backingFieldName}Set)"))
						{
							builder.AppendLineIndented($"backingFieldOwnerInstance.{backingFieldName} = ({propertyTypeName})instance.GetValue({propertyOwnerTypeName}.{propertyName}Property);");
							builder.AppendLineIndented($"backingFieldOwnerInstance.{backingFieldName}Set = true;");
						}

						builder.AppendLineIndented($"return backingFieldOwnerInstance.{backingFieldName};");
					}
					builder.AppendLineIndented($"else");
					using (builder.BlockInvariant(""))
					{
						builder.AppendLineIndented($"return ({propertyTypeName})instance.GetValue({propertyOwnerTypeName}.{propertyName}Property);");
					}
				}
				else
				{
					builder.AppendLineIndented($"return instance.GetValue({propertyOwnerTypeName}.{propertyName}Property);");
				}
			}

			builder.AppendLineIndented($"private static void Set{propertyName}Value({propertyTargetName} instance, {propertyTypeName} value) => instance.SetValue({propertyOwnerTypeName}.{propertyName}Property, value);");

			GeneratePropertyStorage(builder, propertyName);

			builder.AppendLineIndented($"DependencyProperty.RegisterAttached(");

			BuildPropertyParameters(builder, propertyOwnerType, propertyOwnerTypeName, propertyName, propertyTypeName, metadataOptions, defaultValue);

			if (localCache)
			{
				using (builder.BlockInvariant($"\t\t, backingFieldUpdateCallback: (instance, newValue) => "))
				{
					using (builder.BlockInvariant($"if(instance is {backingFieldOwnerTypeName} backingFieldOwnerInstance)"))
					{
						builder.AppendLineIndented($"backingFieldOwnerInstance.{backingFieldName} = ({propertyTypeName})instance.GetValue({propertyOwnerTypeName}.{propertyName}Property);");
						builder.AppendLineIndented($"backingFieldOwnerInstance.{backingFieldName}Set = true;");
					}
				}
			}

			if (coerceCallback || propertyOwnerType.GetFirstMethodWithName("Coerce" + propertyName) is not null)
			{
				builder.AppendLineIndented($"\t\t, coerceValueCallback: (instance, baseValue) => Coerce{propertyName}(instance, ({propertyTypeName})baseValue)");
			}

			changedCallbackName ??= $"On{propertyName}Changed";
			var propertyChangedMethods = propertyOwnerType.GetMethodsWithName(changedCallbackName).ToArray();
			if (changedCallback || (propertyChangedMethods?.Any() ?? false))
			{
				if (propertyChangedMethods.FirstOrDefault(m => IsCallbackWithDPChangedArgs(m, dependencyPropertyChangedEventArgsSymbol)) is { } callbackWithEventArgs)
				{
					builder.AppendLineIndented($"\t\t, propertyChangedCallback: (instance, args) => {changedCallbackName}(instance, args)");
				}
				else if (propertyChangedMethods.FirstOrDefault(m => IsCallbackWithDPChangedArgsOnly(m, dependencyPropertyChangedEventArgsSymbol)) is { } callbackWithEventArgsOnly)
				{
					builder.AppendLineIndented($"\t\t, propertyChangedCallback: (instance, args) => {changedCallbackName}(args)");
				}
				else if (propertyChangedMethods?.FirstOrDefault(m => m?.Parameters.Length == 2) is { } callbackWithOldAndNew)
				{
					builder.AppendLineIndented($"\t\t, propertyChangedCallback: (instance, args) => {changedCallbackName}(({propertyTypeName})args.OldValue, ({propertyTypeName})args.NewValue)");
				}
				else
				{
					builder.AppendLineIndented($"#error Valid {changedCallbackName} not found.  Must be {changedCallbackName}(DependencyPropertyChangedEventArgs), {changedCallbackName}(Instance, DependencyPropertyChangedEventArgs) or {changedCallbackName}(oldValue, newValue)");
				}
			}

			builder.AppendLineIndented($"));");

			builder.AppendLineIndented($"#endregion");
		}

		private static bool IsCallbackWithDPChangedArgsOnly(IMethodSymbol m, INamedTypeSymbol dependencyPropertyChangedEventArgsSymbol)
			=> SymbolEqualityComparer.Default.Equals(m?.Parameters.FirstOrDefault()?.Type, dependencyPropertyChangedEventArgsSymbol);

		private static bool IsCallbackWithDPChangedArgs(IMethodSymbol m, INamedTypeSymbol dependencyPropertyChangedEventArgsSymbol)
			=> m?.Parameters.Length == 2 && SymbolEqualityComparer.Default.Equals(m?.Parameters[1].Type, dependencyPropertyChangedEventArgsSymbol);

		private static KeyValuePair<string, TypedConstant>? GetAttributeValue(AttributeData attribute, string parameterName)
			=> attribute?.NamedArguments.FirstOrDefault(kvp => kvp.Key == parameterName);

		private static bool GetBooleanAttributeValue(AttributeData attribute, string parameterName, bool defaultValue)
			=> attribute?.NamedArguments.FirstOrDefault(kvp => kvp.Key == parameterName).Value.Value is bool value ? value : defaultValue;

		private static void GenerateProperty(IndentedStringBuilder builder, INamedTypeSymbol ownerType, ISymbol memberSymbol, AttributeData attribute, INamedTypeSymbol dependencyPropertyChangedEventArgsSymbol)
		{
			var propertyName = memberSymbol.Name.TrimEnd("Property", StringComparison.Ordinal);

			var propertySymbol = ownerType.GetPropertiesWithName(propertyName).FirstOrDefault();

			if (propertySymbol == null)
			{
				builder.AppendLineIndented($"#error unable to find property {propertyName} on {ownerType}");
				return;
			}

			var propertyTypeName = propertySymbol.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var containingTypeName = propertySymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
			var changedCallbackName = GetAttributeValue(attribute, "ChangedCallbackName")?.Value.Value?.ToString();
			var metadataOptions = GetAttributeValue(attribute, "Options")?.Value.Value?.ToString() ?? "0";
			var coerceCallback = GetBooleanAttributeValue(attribute, "CoerceCallback", false);
			var changedCallback = GetBooleanAttributeValue(attribute, "ChangedCallback", false);
			var localCache = GetBooleanAttributeValue(attribute, "LocalCache", true);
			var defaultValue = GetAttributeValue(attribute, "DefaultValue");

			ValidateInvocation(builder, propertySymbol, $"Get{propertyName}Value", $"Set{propertyName}Value");
			ValidateInvocation(builder, memberSymbol, $"Create{propertyName}Property");

			builder.AppendLineIndented($"");
			builder.AppendLineIndented($"");
			builder.AppendLineIndented($"#region {propertyName} Dependency Property");

			if (propertySymbol.GetMethod != null)
			{
				using (builder.BlockInvariant($"private {propertyTypeName} Get{propertyName}Value()"))
				{
					if (localCache)
					{
						using (builder.BlockInvariant($"if (!_{propertyName}PropertyBackingFieldSet)"))
						{
							builder.AppendLineIndented($"_{propertyName}PropertyBackingField = ({propertyTypeName})GetValue({propertyName}Property);");
							builder.AppendLineIndented($"_{propertyName}PropertyBackingFieldSet = true;");
						}

						builder.AppendLineIndented($"return _{propertyName}PropertyBackingField;");
					}
					else
					{
						builder.AppendLineIndented($"return ({propertyTypeName})GetValue({propertyName}Property);");
					}
				}
			}

			if (propertySymbol.SetMethod != null)
			{
				builder.AppendLineIndented($"private void Set{propertyName}Value({propertyTypeName} value) => SetValue({propertyName}Property, value);");
			}

			if (localCache)
			{
				builder.AppendLineIndented($"private bool _{propertyName}PropertyBackingFieldSet = false;");
				builder.AppendLineIndented($"private {propertyTypeName} _{propertyName}PropertyBackingField;");
			}

			GeneratePropertyStorage(builder, propertyName);

			builder.AppendLineIndented($"DependencyProperty.Register(");

			BuildPropertyParameters(builder, propertySymbol.ContainingType, containingTypeName, propertyName, propertyTypeName, metadataOptions, defaultValue);

			if (localCache)
			{
				// Use a explicit delegate to avoid C# delegate caching (the delegate is kept in the DP, no need to cache it in the class)
				builder.AppendLineIndented($"\t\t, backingFieldUpdateCallback: On{propertyName}BackingFieldUpdate");
			}

			if (coerceCallback || propertySymbol.ContainingType.GetFirstMethodWithName("Coerce" + propertyName) is not null)
			{
				builder.AppendLineIndented($"\t\t, coerceValueCallback: (instance, baseValue) => (({containingTypeName})instance).Coerce{propertyName}(baseValue)");
			}

			changedCallbackName ??= $"On{propertyName}Changed";
			var propertyChangedMethods = propertySymbol.ContainingType.GetMethodsWithName(changedCallbackName).ToArray();
			if (changedCallback || propertyChangedMethods.Any())
			{
				if (propertyChangedMethods.FirstOrDefault(m => IsCallbackWithDPChangedArgs(m, dependencyPropertyChangedEventArgsSymbol)) is { } callbackWithEventArgs)
				{
					builder.AppendLineIndented($"\t\t, propertyChangedCallback: (instance, args) => (({containingTypeName})instance).{changedCallbackName}(instance, args)");
				}
				else if (propertyChangedMethods.FirstOrDefault(m => IsCallbackWithDPChangedArgsOnly(m, dependencyPropertyChangedEventArgsSymbol)) is { } callbackWithEventArgsOnly)
				{
					builder.AppendLineIndented($"\t\t, propertyChangedCallback: (instance, args) => (({containingTypeName})instance).{changedCallbackName}(args)");
				}
				else if (propertyChangedMethods?.FirstOrDefault(m => m?.Parameters.Length == 2) is { } callbackWithOldAndNew)
				{
					builder.AppendLineIndented($"\t\t, propertyChangedCallback: (instance, args) => (({containingTypeName})instance).{changedCallbackName}(({propertyTypeName})args.OldValue, ({propertyTypeName})args.NewValue)");
				}
				else
				{
					builder.AppendLineIndented($"#error Valid {changedCallbackName} not found.  Must be {changedCallbackName}(DependencyPropertyChangedEventArgs), {changedCallbackName}(Instance, DependencyPropertyChangedEventArgs) or {changedCallbackName}(oldValue, newValue)");
				}
			}

			builder.AppendLineIndented($"));");

			if (localCache)
			{
				using (builder.BlockInvariant($"private static void On{propertyName}BackingFieldUpdate(object instance, object newValue)"))
				{
					builder.AppendLineIndented($"var typedInstance = instance as {containingTypeName};");
					builder.AppendLineIndented($"typedInstance._{propertyName}PropertyBackingField = ({propertyTypeName})newValue;");
					builder.AppendLineIndented($"typedInstance._{propertyName}PropertyBackingFieldSet = true;");
				}
			}

			builder.AppendLineIndented($"#endregion");
		}

		private static void ValidateInvocation(IndentedStringBuilder builder, ISymbol propertySymbol, params string[] invocations)
		{
			if (propertySymbol.Locations.FirstOrDefault() is Location location)
			{
				if (location.SourceTree != null)
				{
					var node = location.SourceTree.GetRoot().FindNode(location.SourceSpan);
					var syntaxNodeContent = node.ToString();

					if (!invocations.All(l => syntaxNodeContent.Contains(l, StringComparison.Ordinal)))
					{
						var invocationsMessage = string.Join(", ", invocations);
						builder.AppendLineIndented($"#error unable to find some of the following statements {invocationsMessage} in {propertySymbol}");
					}
				}
			}
		}

		private static void GeneratePropertyStorage(IndentedStringBuilder builder, string propertyName)
		{
			builder.AppendLineIndented($"/// <summary>");
			builder.AppendLineIndented($"/// Generated method used to create the <see cref=\"{propertyName}Property\" /> member value");
			builder.AppendLineIndented($"/// </summary>");
			builder.AppendLineIndented($"private static global::Windows.UI.Xaml.DependencyProperty Create{propertyName}Property() => ");
		}

		private static void BuildPropertyParameters(
			IndentedStringBuilder builder,
			INamedTypeSymbol ownerType,
			string containingTypeName,
			string propertyName,
			string propertyTypeName,
			string? metadataOptions,
			KeyValuePair<string, TypedConstant>? defaultValue)
		{
			builder.AppendLineIndented($"\tname: \"{propertyName}\",");
			builder.AppendLineIndented($"\tpropertyType: typeof({propertyTypeName}),");
			builder.AppendLineIndented($"\townerType: typeof({containingTypeName}),");
			builder.AppendLineIndented($"\ttypeMetadata: new global::Windows.UI.Xaml.FrameworkPropertyMetadata(");

			var defaultValueMethodName = $"Get{propertyName}DefaultValue()";
			if (defaultValue.HasValue && !string.IsNullOrEmpty(defaultValue.Value.Key))
			{
				if (ownerType.GetFirstMethodWithName(defaultValueMethodName) is not null)
				{
					builder.AppendLineIndented($"#error The generated property {propertyName} cannot contains both a DefaultValue and the {defaultValueMethodName} method.");
				}

				var defaultValueString = defaultValue.Value.Value.Value switch
				{
					string s => $"\"{s}\"",
					double d when double.IsPositiveInfinity(d) => "double.PositiveInfinity",
					double d when double.IsNegativeInfinity(d) => "double.NegativInfinity",
					double d when double.IsNaN(d) => "double.NaN",
					double d => d.ToString(CultureInfo.InvariantCulture),
					float d when float.IsPositiveInfinity(d) => "float.PositiveInfinity",
					float d when float.IsNegativeInfinity(d) => "float.NegativInfinity",
					float d when float.IsNaN(d) => "float.NaN",
					float d => d.ToString(CultureInfo.InvariantCulture) + "f",
					bool d => d.ToString(CultureInfo.InvariantCulture).ToLowerInvariant(),
					var o => o?.ToString() ?? "null",
				};

				builder.AppendLineIndented($"\t\tdefaultValue: ({propertyTypeName}){defaultValueString} /* {defaultValueMethodName}, {ownerType} */");
			}
			else
			{
				builder.AppendLineIndented($"\t\tdefaultValue: Get{propertyName}DefaultValue()");
			}

			if (metadataOptions != "0")
			{
				builder.AppendLineIndented($"\t\t, options: (global::Windows.UI.Xaml.FrameworkPropertyMetadataOptions){metadataOptions}");
			}
		}

		private static IDisposable GenerateNestingContainers(IndentedStringBuilder builder, INamedTypeSymbol? typeSymbol)
		{
			var disposables = new List<IDisposable>();

			var currentSymbol = typeSymbol;

			while (currentSymbol?.ContainingType != null)
			{
				disposables.Add(builder.BlockInvariant($"partial class {typeSymbol?.ContainingType.Name}"));

				currentSymbol = currentSymbol?.ContainingType;
			}

			return new DisposableAction(() => disposables.ForEach(d => d.Dispose()));
		}
	}
}
