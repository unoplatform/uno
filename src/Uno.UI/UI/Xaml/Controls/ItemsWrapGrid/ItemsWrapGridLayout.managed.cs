// <auto-generated />
#if !IS_UNIT_TESTS
using System;
using System.Collections.Generic;
using System.Text;
using Uno.UI;
using Windows.Foundation;
using Microsoft.UI.Xaml.Controls.Primitives;
using static System.Math;

namespace Microsoft.UI.Xaml.Controls
{
#if __ANDROID__ || __APPLE_UIKIT__
	internal partial class ManagedItemsWrapGridLayout : ManagedVirtualizingPanelLayout
#else
	partial class ItemsWrapGridLayout
#endif
	{
		//These properties are set to the dimensions of the first materialised item, and used if ItemWidth/ItemHeight are set to auto
		private double? _implicitItemWidth;
		private double? _implicitItemHeight;

#if __ANDROID__ || __APPLE_UIKIT__
		public override Orientation ScrollOrientation => Orientation == Orientation.Horizontal ? Orientation.Vertical : Orientation.Horizontal;
#endif

		private protected override Line CreateLine(GeneratorDirection fillDirection, double extentOffset, double availableBreadth, Uno.UI.IndexPath nextVisibleItem)
		{
			if (ShouldInsertReorderingView(extentOffset) && GetAndUpdateReorderingIndex() is { } reorderingIndex)
			{
				nextVisibleItem = reorderingIndex;
			}

			var itemsInLine = ResolveMaximumItemsInLine(availableBreadth);
			var firstItemInLine = nextVisibleItem;

			// Find first item in line, since the item we are passed is the last
			if (fillDirection == GeneratorDirection.Backward)
			{
				// We are recreating the last line of the group - it may be truncated (if the total items are not an even multiple
				// of the items-per-line).
				var totalItems = ItemsControl?.NumberOfItems ?? 0;
				if (totalItems > 0)
				{
					var itemsInLastLine = totalItems % itemsInLine;
					if (itemsInLastLine == 0)
					{
						itemsInLastLine = itemsInLine;
					}
					var itemsToBacktrack = itemsInLastLine - 1;

					// Get first item flat index and calculate how many items we need to traverse backward
					var currentFlat = GetFlatItemIndex(nextVisibleItem);
					var remaining = currentFlat % itemsInLine;
					itemsToBacktrack = Min(itemsToBacktrack, remaining);

					for (int i = 0; i < itemsToBacktrack; i++)
					{
						var prev = GetNextUnmaterializedItem(GeneratorDirection.Backward, firstItemInLine);
						if (prev == null)
						{
							break;
						}
						firstItemInLine = prev.Value;
					}
				}
			}

			Uno.UI.IndexPath? currentItem = firstItemInLine;
			var items = new List<(FrameworkElement container, Uno.UI.IndexPath index)>();

			double breadthOffset = 0;
			int itemsAdded = 0;

			for (int i = 0; i < itemsInLine && currentItem != null; i++)
			{
				var flatIndex = GetFlatItemIndex(currentItem.Value);
				var view = Generator.DequeueViewForItem(flatIndex);

				// Measure and get the item size
				var slotSize = GetItemSlotSize(availableBreadth);
				view.Measure(slotSize);
				var desiredSize = view.DesiredSize;

				// Set implicit item dimensions on first item
				if (_implicitItemWidth == null && !double.IsNaN(desiredSize.Width))
				{
					_implicitItemWidth = desiredSize.Width;
				}
				if (_implicitItemHeight == null && !double.IsNaN(desiredSize.Height))
				{
					_implicitItemHeight = desiredSize.Height;
				}

				// Recalculate items per line now that we have item dimensions
				if (i == 0 && _implicitItemWidth.HasValue && _implicitItemHeight.HasValue)
				{
					itemsInLine = ResolveMaximumItemsInLine(availableBreadth);
				}

				var itemBreadth = ResolveItemBreadth() ?? GetBreadth(desiredSize);

				AddView(view, fillDirection, extentOffset, breadthOffset);

				items.Add((view, currentItem.Value));
				breadthOffset += itemBreadth;
				itemsAdded++;

				currentItem = GetNextUnmaterializedItem(GeneratorDirection.Forward, currentItem);
			}

			var firstItemFlat = GetFlatItemIndex(firstItemInLine);
			return new Line(firstItemFlat, items.ToArray());
		}

		private Size GetItemSlotSize(double availableBreadth)
		{
			var itemWidth = ResolveAvailableWidth(availableBreadth);
			var itemHeight = ResolveAvailableHeight(availableBreadth);
			return new Size(itemWidth, itemHeight);
		}

		/// <summary>
		/// Resolve the width available for a single item view, using, in decreasing order of priority, the ItemWidth if
		/// defined, the width of the first item in the grid, or the maximum available space if we are measuring the first item.
		/// </summary>
		private double ResolveAvailableWidth(double availableBreadth)
		{
			if (!double.IsNaN(ItemWidth))
			{
				return ItemWidth;
			}

			if (_implicitItemWidth.HasValue)
			{
				return _implicitItemWidth.Value;
			}

			if (ScrollOrientation == Orientation.Vertical)
			{
				return availableBreadth;
			}
			else
			{
				return double.PositiveInfinity;
			}
		}

		/// <summary>
		/// Resolve the height available for a single item view, using, in decreasing order of priority, the ItemHeight if
		/// defined, the height of the first item in the grid, or the maximum available space if we are measuring the first item.
		/// </summary>
		private double ResolveAvailableHeight(double availableBreadth)
		{
			if (!double.IsNaN(ItemHeight))
			{
				return ItemHeight;
			}

			if (_implicitItemHeight.HasValue)
			{
				return _implicitItemHeight.Value;
			}

			if (ScrollOrientation == Orientation.Vertical)
			{
				return double.PositiveInfinity;
			}
			else
			{
				return availableBreadth;
			}
		}

		/// <summary>
		/// Resolve the breadth of items in the grid, if it is known.
		/// </summary>
		private double? ResolveItemBreadth()
		{
			if (ScrollOrientation == Orientation.Vertical)
			{
				return ResolveItemWidth();
			}
			else
			{
				return ResolveItemHeight();
			}
		}

		/// <summary>
		/// Resolve the extent of items in the grid, if it is known.
		/// </summary>
		private double? ResolveItemExtent()
		{
			if (ScrollOrientation == Orientation.Vertical)
			{
				return ResolveItemHeight();
			}
			else
			{
				return ResolveItemWidth();
			}
		}

		/// <summary>
		/// Resolve the width of items in the grid, if it is known.
		/// </summary>
		private double? ResolveItemWidth()
		{
			if (!double.IsNaN(ItemWidth))
			{
				return ItemWidth;
			}

			return _implicitItemWidth;
		}

		/// <summary>
		/// Resolve the height of items in the grid, if it is known.
		/// </summary>
		private double? ResolveItemHeight()
		{
			if (!double.IsNaN(ItemHeight))
			{
				return ItemHeight;
			}

			return _implicitItemHeight;
		}

		/// <summary>
		/// Resolve the items per line, limited by dimensions and/or MaximumRowsOrColumns
		/// </summary>
		private int ResolveMaximumItemsInLine(double availableBreadth)
		{
			var itemBreadth = ResolveItemBreadth();
			var maximumItemsBySpace = itemBreadth.HasValue && itemBreadth.Value > 0
				? (int)(availableBreadth / itemBreadth.Value)
				: 1;
			// Catch pathological case that item returns a measured breadth larger than its available space
			maximumItemsBySpace = Max(maximumItemsBySpace, 1);
			var maximumItemsBySetting = MaximumRowsOrColumns == -1 ? int.MaxValue : MaximumRowsOrColumns;
			return Min(maximumItemsBySetting, maximumItemsBySpace);
		}

		protected override int GetItemsPerLine()
		{
			// This is used for extent estimation, so return the current best guess
			var itemBreadth = ResolveItemBreadth();
			if (itemBreadth.HasValue && itemBreadth.Value > 0)
			{
				// We need AvailableBreadth here, but it's not directly accessible
				// Use MaximumRowsOrColumns if set, otherwise estimate from implicit dimensions
				if (MaximumRowsOrColumns > 0)
				{
					return MaximumRowsOrColumns;
				}
				// Default to 1 if we can't determine (will be recalculated when breadth is known)
				return 1;
			}
			return 1;
		}

		protected override Rect GetElementArrangeBounds(int elementIndex, Rect containerBounds, Size windowConstraint, Size finalSize)
		{
			// For ItemsWrapGrid, we don't stretch items - they stay at their measured size
			return containerBounds;
		}

		private protected override Uno.UI.IndexPath? GetDynamicSeedIndex(Uno.UI.IndexPath? firstVisibleItem)
		{
			// Get the first preceding item that is at the end of a line
			var currentItem = firstVisibleItem;
			var itemsPerLine = GetItemsPerLine();

			while (currentItem != null)
			{
				currentItem = GetNextUnmaterializedItem(GeneratorDirection.Backward, currentItem);
				if (currentItem?.Section != firstVisibleItem?.Section)
				{
					return currentItem;
				}
				if ((currentItem?.Row + 1) % itemsPerLine == 0)
				{
					return currentItem;
				}
			}
			return null;
		}

		internal void ResetLayoutInfo()
		{
			_implicitItemWidth = null;
			_implicitItemHeight = null;
		}
	}
}

#endif
